Transport
#########

Overview
========

Raiden is a network agnostic protocol. Protocol messages can in general be transferred over
any network, e.g. ip, mesh networks, etc., where the only requirement is access to an
Ethereum node.
For efficient and reliable messaging, the reference implementation of Raiden currently **only**
supports Matrix, an open standard for peer-to-peer messaging based on a server federation.


Requirements
============
* Unicast Messages
* Broadcast Messages
* E2E encryption for unicast messages
* Authentication (i.e. messages should be linkable to an Ethereum account)
* Low latency (~100ms)
* Scalability
* Spam protection / Sybil Attack resistance
* Decentralization (no single point of failure / censorship resistance)
* Off the shelf solution, well maintained
* JS + Python SDK
* Open Source / Open Protocol

Current Solution: Federation of Matrix Homeservers
===================================================
https://matrix.org/docs/guides/faq.html

Matrix is a federated open source messaging system, which supports group communication
(multicast) via chat rooms. Direct messages are modeled as 2 participants in a private chat room.
Homeservers can be extended with custom logic (application services, password providers) e.g. to enforce certain rules (or message formats) in a room.
It provides JS and Python bindings and communication is done via REST API and HTTP long polling.



Use in Raiden
=============

Identity
--------

The identity verification MUST not be tied to Matrix identities.
Even though Matrix provides an identity system, it is a possible central point of failure.
All state-changing messages passed between participants MUST be signed using the private key of the ethereum account,
using Matrix only as a transport layer.

The messages MUST be validated using ecrecover by receiving parties.

The conventions below provide the means for the discovery process, and affect only the transport layer (thus not tying the whole stack to Matrix).

Authentication
--------------

A Matrix ``userId`` is required to be of the form ``@<eth-address>:<homeserver-uri>``, an ``@``, followed by
the lowercased ``0x`` prefixed ethereum address of the node and the homeserver uri, separated from the username by a colon.

To prevent malicious name squatting all Matrix servers joining the Raiden federation must enforce the following rules:

#. Account registration must be disabled
#. A password provider that ensures only users in control of the private key corresponding to their node address can log in.
   This is done by using an ec-recoverable signature of the server name the Raiden node is connecting to (without any protocol prefix) as the password.
   The password provider must verify the following:

   #. The user-id matches the format described above.
   #. The ``homeserver_uri`` part of the user-id matches the local hostname.
   #. The password is a valid ``0x`` prefixed, hex encoded ec-recoverable signature of the local hostname.
   #. The recovered address matches the ``eth-address`` part of the user-id.

#. Every Raiden node must set it's Matrix ``displayName`` to a ``0x`` prefixed hex encoded ec-recoverable signature of their complete user-id.

Example:
::

    username = web3.eth.defaultAccount  # 0-left-padded
    # 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
    password = web3.eth.sign(server_uri)
    matrix.login_with_password(username, password)
    userid = "@" + username + ":" + server_uri
    matrix.get_user(userid).set_display_name(web3.eth.sign(userid))

Discovery
---------

All Raiden nodes must join a globally federated discovery room to allow for server-side user directory searches.
The name of the discovery room is of the form ``raiden_<network_name_or_id>_discovery`` (e.g. ``raiden_mainnet_discovery``).

User search results need to be checked by validating their ``displayName`` signature.

The discovery rooms are not intended to exchange messages in.
Clients should use the server-side filtering mechanism to exclude message data of the discovery rooms.


Presence
--------

Matrix allows to check for the presence of a user. Clients should listen for changes in presence status of users of interest (e.g. peers), and update user status if required (e.g. gone offline), which will allow the Raiden node to avoid trying to use this user e.g. for mediating transfers.

Sending transfer messages to other nodes
----------------------------------------

Private channel rooms have random room_ids in the format ``!<random_room_id>:<homeserver-uri>``, where the ``random room_id`` is generated by the server.
To avoid race conditions only the node with the lexicographically lower address will create rooms and invite peers.

Since users may roam to other homeservers, participants should keep listening for user-join events in the discovery room.
When a new user for an address of interest joins it should be invited into a communications room.


Chat Rooms
----------

Peer discovery room
'''''''''''''''''''
One per network. Participants can discover peers willing to open more channels. It may be implemented in the future as one presence/peer discovery room per token network, but it'd complicate the room-ownership/creation/server problem (rooms need to belong to a server. Whose server? Who created it? Who has admin rights for it?).

Monitoring Service Updates Room
'''''''''''''''''''''''''''''''
Raiden nodes can submit a :term:`MonitoringRequest` to the Monitoring Service room when they go
offline. The Monitoring Service will submit their balance proof on their behalf.

Pathfinding Service Updates Room
''''''''''''''''''''''''''''''''
Raiden Nodes publish :term:`PFSCapacityUpdate` and :term:`PFSFeeUpdate` to the Pathfinding Service room. The Pathfinding Service can
 compute efficient routes throughout the network and provide these routes to requesting nodes.
